#ifndef SBUF_H
#define SBUF_H

#include <semaphore.h>

/**
 * 在并发编程中，使用信号量（sem_t）来记录槽位数量（slots）和可用项目数量（items），而不是简单的整数变量（int），有几个重要原因：
 * 1. 原子操作：信号量提供原子性操作，可以确保在多个线程同时访问和修改这些计数器时不会发生竞态条件。
 * 信号量的增减操作（sem_wait 和 sem_post）是原子的，能够避免多个线程同时修改计数器导致的不一致问题。
 * 
 * 2.同步机制：信号量不仅能记录数量，还能提供一种同步机制。slots 信号量用于表示可用的空槽位，items 信号量用于表示缓冲区中的可用项目数量。
 * 当一个线程试图向缓冲区中插入一个项目时，它必须先等待slots信号量，这样可以确保有空位可用。
 * 同样，当一个线程试图从缓冲区中取出一个项目时，它必须先等待items信号量，这样可以确保有项目可用。
 * 
 * 3.阻塞与唤醒：信号量可以使线程在没有可用资源时进入阻塞状态，而不是不断轮询和消耗CPU资源。
 * 当资源变得可用时，信号量会自动唤醒等待的线程。例如，当缓冲区已满时，生产者线程会在slots信号量上等待，直到有空位。
 * 当缓冲区为空时，消费者线程会在items信号量上等待，直到有可用项目。
 * 
 * 4.简化并发控制：使用信号量可以简化代码中的并发控制逻辑，而不需要手动管理复杂的锁和条件变量。信号量提供了一种简洁且有效的机制来处理资源的分配和同步。
 */  
typedef struct {
    int *buf;   // 缓冲区，用于保存接收到的clientfd
    int n;  // 最大插槽数量
    int front;  // buf[(front + 1) % n] 是第一项
    int rear;   // buf[rear % n] 是最后一项
    sem_t mutex;    // 控制对缓冲区访问的互斥量
    sem_t slots;    // 记录空槽位数量
    sem_t items;    // 记录可用项目数量
} sbuf_t;

void sbuf_init(sbuf_t *sp, int n);  // 为缓冲区分配堆内存 设置front和rear表示一个空的缓冲区 为三个信号量赋初始值
void sbuf_deinit(sbuf_t *sp);   // 释放缓冲区存储
void sbuf_insert(sbuf_t *sp, int item); // 等待一个可用槽位，对互斥锁加锁，添加项目，对互斥锁解锁，然后宣布一个新项目可用
int sbuf_remove(sbuf_t *sp); // 等待一个可用的缓冲区项目后，对互斥锁加锁，从缓冲区的前面取出该项目，对互斥锁解锁，然后发信号通知一个新的槽位可用

#endif
